### Lesson 7 - Functions  
+ *Functions* can be used to write more complex rules. Two examples:
    + `wildcard` - gets a list of files matching some pattern, which can then
    be saved in a variable. For example - `TXT_FILES=$(wildcard books/*.txt)`
    + `patsubst` - pattern substitution. Takes a pattern, a replacement string,
    and a list of names in that order. Each name in the list that matches the
    pattern is replaced by the replacement string. This can be used to rewrite
    the lsit of text files to a list of data files and save them in a variable.
    `DAT_FILES=$(patsubst books/%.txt, %.dat, $(TXT_FILES))`  

____

Using these functions, the final Makefile can be written as:

```make
include config.mk

TXT_FILES=$(wildcard books/*.txt)
DAT_FILES=$(patsubst books/%.txt, %.dat, $(TXT_FILES))

# Generate summary table.
results.txt : $(ZIPF_SRC) $(DAT_FILES)
	$(ZIPF_EXE) $(DAT_FILES) > $@

# Count words.
.PHONY : dats
dats : $(DAT_FILES)

%.dat : books/%.txt $(COUNT_SRC)
	$(COUNT_EXE) $< $@

.PHONY : clean
clean :
	rm -f $(DAT_FILES)
	rm -f results.txt

.PHONY : variables
variables:
	@echo TXT_FILES: $(TXT_FILES)
	@echo DAT_FILES: $(DAT_FILES)
```

The associated `config.mk` for this Makefile:

```make
# Count words script.
LANGUAGE=python
COUNT_SRC=countwords.py
COUNT_EXE=$(LANGUAGE) $(COUNT_SRC)

# Test Zipf's rule
ZIPF_SRC=testzipf.py
ZIPF_EXE=$(LANGUAGE) $(ZIPF_SRC)
```

+ Note that `@echo` is used to suppress Make outputting the literal command to
be executed, and only showing the output generated by the `echo` command itself.
